import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# ====== 1. 변수 설정 ======
# 우주 거울의 궤도 케플러 요소 (화성 중심)
semi_major_axis = 10500e3      # 반장축 (m)
eccentricity = 0.01            # 이심률
inclination = np.deg2rad(25)   # 경사각 (rad)
raan = np.deg2rad(0)           # 승교점 경도 (rad)
arg_periapsis = np.deg2rad(0)  # 근일점 인수 (rad)
true_anomaly = np.deg2rad(0)   # 진이각 (rad)

# 오일러 방법 변수
dt = 60.0                      # 시간 간격 (초)
total_time = 86400             # 전체 시뮬레이션 시간 (초)
num_steps = int(total_time / dt)

# 우주 거울 변수
mirror_size = 1000             # 거울 한 변의 길이 (m)
mirror_angle = 45              # 거울 각도 (deg, 실제 시뮬레이션에서는 입사각에 따라 동적으로 계산)
mirror_reflectivity = 0.9      # 반사율

# 화성 중심 표준중력상수 (m^3/s^2)
mu_mars = 4.282837e13

# 화성 반지름 및 태양-화성 거리
mars_radius = 3389.5e3         # m
mars_sun_distance = 227.9e9    # m (평균)

# 태양 상수 (1AU에서, W/m^2)
solar_constant_1AU = 1361

# ====== 2. 케플러 요소 → 초기 위치/속도 변환 함수 ======
def kepler_to_cartesian(a, e, i, raan, argp, ta, mu):
    r = a * (1 - e**2) / (1 + e * np.cos(ta))
    x_p = r * np.cos(ta)
    y_p = r * np.sin(ta)
    z_p = 0

    h = np.sqrt(mu * a * (1 - e**2))
    vx_p = -mu/h * np.sin(ta)
    vy_p = mu/h * (e + np.cos(ta))
    vz_p = 0

    cos_raan = np.cos(raan)
    sin_raan = np.sin(raan)
    cos_i = np.cos(i)
    sin_i = np.sin(i)
    cos_argp = np.cos(argp)
    sin_argp = np.sin(argp)

    R = np.array([
        [cos_raan*cos_argp - sin_raan*sin_argp*cos_i, -cos_raan*sin_argp - sin_raan*cos_argp*cos_i, sin_raan*sin_i],
        [sin_raan*cos_argp + cos_raan*sin_argp*cos_i, -sin_raan*sin_argp + cos_raan*cos_argp*cos_i, -cos_raan*sin_i],
        [sin_argp*sin_i, cos_argp*sin_i, cos_i]
    ])

    r_vec = R @ np.array([x_p, y_p, z_p])
    v_vec = R @ np.array([vx_p, vy_p, vz_p])
    return r_vec, v_vec

# ====== 3. 초기 위치/속도 ======
# 우주 거울 (화성 중심 궤도)
r, v = kepler_to_cartesian(semi_major_axis, eccentricity, inclination, raan, arg_periapsis, true_anomaly, mu_mars)

# 화성 (태양 중심 궤도, 원궤도 단순화)
mars_theta = 0
mars_angular_speed = 2 * np.pi / (687 * 24 * 3600)  # 화성 공전주기(초) 기준 각속도

# ====== 4. 시뮬레이션 ======
positions = []
velocities = []
mars_positions = []
energy_to_mars = []

for step in range(num_steps):
    # 1) 우주 거울 궤도 적분 (화성 중심)
    r_norm = np.linalg.norm(r)
    a_grav = -mu_mars * r / r_norm**3
    v = v + a_grav * dt
    r = r + v * dt
    positions.append(r.copy())
    velocities.append(v.copy())

    # 2) 화성 위치 (태양 중심, 원궤도 단순화)
    mars_theta += mars_angular_speed * dt
    mars_pos = np.array([
        mars_sun_distance * np.cos(mars_theta),
        mars_sun_distance * np.sin(mars_theta),
        0
    ])
    mars_positions.append(mars_pos.copy())

    # 3) 태양-거울 거리 (화성 위치 + 거울 위치)
    mirror_global = mars_pos + r  # 태양 기준 거울 위치
    sun_to_mirror = np.linalg.norm(mirror_global)
    S_mirror = solar_constant_1AU * (1.496e11 / sun_to_mirror)**2

    # 4) 거울-화성 거리 (화성 중심 좌표계)
    mirror_to_mars = np.linalg.norm(r)
    # 5) 입사각(거울 노멀과 화성 방향의 각도)
    sun_vec = -mirror_global  # 태양->거울
    mars_vec = -r             # 거울->화성(화성 중심)
    sun_vec_unit = sun_vec / np.linalg.norm(sun_vec)
    mars_vec_unit = mars_vec / np.linalg.norm(mars_vec)
    cos_theta = np.dot(sun_vec_unit, mars_vec_unit)
    cos_theta = max(cos_theta, 0)

    mirror_area = mirror_size ** 2  # m^2
    reflected = mirror_area * mirror_reflectivity * S_mirror * cos_theta * dt
    reflected_on_mars = reflected * (1 / (mirror_to_mars)**2) if mirror_to_mars > 0 else 0
    energy_to_mars.append(reflected_on_mars)

# ====== 5. 결과 출력 및 시각화 ======
print(f"시뮬레이션 동안 화성에 도달한 반사 태양 에너지(실제 궤도 기반): {np.sum(energy_to_mars):.2e} J")

positions_np = np.array(positions)
mars_positions_np = np.array(mars_positions)
mirror_global_np = mars_positions_np + positions_np

fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(111, projection='3d')
ax.plot(mars_positions_np[:,0], mars_positions_np[:,1], mars_positions_np[:,2], label='Mars Orbit', color='red')
ax.plot(mirror_global_np[:,0], mirror_global_np[:,1], mirror_global_np[:,2], label='Mirror Orbit', color='blue')
ax.scatter(0, 0, 0, color='orange', label='Sun', s=100)
ax.set_xlabel('X (m)')
ax.set_ylabel('Y (m)')
ax.set_zlabel('Z (m)')
ax.set_title('3D Orbit of Space Mirror around Mars (Heliocentric)')
ax.legend()
plt.show()

# 3차원 애니메이션 (태양, 화성, 우주거울)
fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(111, projection='3d')
ax.set_xlabel('X (m)')
ax.set_ylabel('Y (m)')
ax.set_zlabel('Z (m)')
ax.set_title('3D Animation: Sun, Mars, Space Mirror')
ax.plot(mars_positions_np[:,0], mars_positions_np[:,1], mars_positions_np[:,2], color='red', alpha=0.2, label='Mars Orbit')
ax.plot(mirror_global_np[:,0], mirror_global_np[:,1], mirror_global_np[:,2], color='blue', alpha=0.2, label='Mirror Orbit')
sun_scatter = ax.scatter([0], [0], [0], color='orange', label='Sun', s=100)
mars_scatter = ax.scatter([mars_positions_np[0,0]], [mars_positions_np[0,1]], [mars_positions_np[0,2]], color='red', label='Mars', s=50)
mirror_scatter = ax.scatter([mirror_global_np[0,0]], [mirror_global_np[0,1]], [mirror_global_np[0,2]], color='blue', label='Mirror', s=30)
ax.legend()
all_xyz = np.concatenate([mars_positions_np, mirror_global_np], axis=0)
max_range = np.ptp(all_xyz, axis=0).max() / 2
mid_x = np.mean(all_xyz[:,0])
mid_y = np.mean(all_xyz[:,1])
mid_z = np.mean(all_xyz[:,2])
ax.set_xlim(mid_x - max_range, mid_x + max_range)
ax.set_ylim(mid_y - max_range, mid_y + max_range)
ax.set_zlim(mid_z - max_range, mid_z + max_range)

def update(frame):
    mars_scatter._offsets3d = ([mars_positions_np[frame,0]], [mars_positions_np[frame,1]], [mars_positions_np[frame,2]])
    mirror_scatter._offsets3d = ([mirror_global_np[frame,0]], [mirror_global_np[frame,1]], [mirror_global_np[frame,2]])
    return mars_scatter, mirror_scatter, sun_scatter

ani = FuncAnimation(fig, update, frames=range(0, len(positions_np), max(1, len(positions_np)//300)), interval=30, blit=False)
plt.show()

plt.figure(figsize=(8,4))
plt.plot(np.arange(num_steps)*dt/3600, np.cumsum(energy_to_mars))
plt.xlabel('Time (hours)')
plt.ylabel('Cumulative Reflected Energy to Mars (J)')
plt.title('Reflected Solar Energy Delivered to Mars Over Time')
plt.grid()
plt.show()
